<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Set up Nginx with HTTP/2 Support]]></title>
    <url>%2Fset-up-nginx-with-http-2-support%2F</url>
    <content type="text"><![CDATA[One of the protocols supported is the relatively new HTTP/2, which was published in May 2015 approximately. One of the main advantages of HTTP/2 is its high transfer speed for content-rich websites. To boost my website as much as possible, I upgraded it with this modern protocol. What is HTTP/2?HTTP/2 (originally named HTTP/2.0) is a major revision of the HTTP network protocol used by the World Wide Web. It was derived from the earlier experimental SPDY protocol, originally developed by Google. HTTP/2 was developed by the Hypertext Transfer Protocol working group httpbis (where bis means “second”) of the Internet Engineering Task Force. HTTP/2 is the first new version of HTTP since HTTP 1.1, which was standardized in RFC 2068 in 1997. Why HTTP/2?In a nutshell, HTTP/2 has been released to address the inherent problems of HTTP1.1: HTTP/2 is binary instead of textual like HTTP1.1 - this makes it transfer and parsing of data over HTTP/2 inherently more machine-friendly, thus faster, more efficient and less error prone. HTTP/2 is fully multiplexed allowing multiple files and requests to be transferred at the same time, as opposed to HTTP1.1 which only accepted one single request / connection at a time. HTTP/2 uses the same connection for transferring different files and requests, avoiding the heavy operation of opening a new connection for every file which needs to be transferred between a client and a server. HTTP/2 has header compression built-in which is another way of removing several of the overheads associated with HTTP1.1 having to retrieve several different resources from the same or multiple web servers. HTTP/2 allows servers to push required resources proactively rather than waiting for the client browser to request files when it thinks it need them. These things are the best (if simplistic) depiction of how HTTP/2 is better than HTTP1.1. Rather than the browser having to go back to the server to fetch every single resource, it’s picking up all the resources and transferring them at once. How to make it?Prerequisites An Nginx-installed Ubuntu OS. A non-root user with the right to sudo. You should have the control right of a domain name and associate it with your Nginx-running server. An SSL certificate. My DigitalOcean VPS is installed with Ubuntu 16.04 LTS x64. This post will also be based on it. Upgrade to the Latest Version of NginxSupport of the HTTP/2 protocol was introduced in Nginx 1.9.5. If you followed my previous tutorial about building Nginx on Ubuntu, you should have had the up-to-date Nginx, so skip this part and go to next step. Fortunately, the default repository in Ubuntu 16.04 contains a version higher than this, so we don’t have to add a third party repository. First, update the list of available packages in the apt packaging system: $ sudo apt-get update Then, install Nginx: $ sudo apt-get install nginx After the installation process finishes, you can check the version of Nginx by typing: $ sudo nginx -v The output should be similar to the following: nginx version: nginx/1.10.3 (Ubuntu) Then you should check your OpenSSL version. HTTP/2 happens to fail to be enabled on machines with OpenSSL lower than 1.0.2. The newer version was released long ago, but just in case, let’s check it out: $ openssl version Then my output is: OpenSSL 1.0.2g 1 Mar 2016 It is good enough for me. But if you found it appears to a number lower than 1.0.2, go ahead google an upgrading solution to fix it. In the next several steps, we will modify the Nginx configuration files. Each step will change an Nginx configuration option. We will test the syntax of the configuration file along the way. Finally, we will verify that Nginx supports HTTP/2 and make a few changes to optimize performance. Change the Listening Port and Enable HTTP/2The first change we will make will be to change the listening port from 80 to 443. Let’s open the configuration file: $ sudo vim /etc/nginx/sites-available/default By default, Nginx is set to listen to port 80, which is the standard HTTP port: listen 80 default_server; listen [::]:80 default_server; As you can see, we have two different listen variables. The first one is for all IPv4 connections. The second one is for IPv6 connections. We will enable encryption for both. Modify the listening port to 443, which is used by the HTTPS protocol: listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; Notice that in addition to ssl, we also added http2 to the line. This variable tells Nginx to use HTTP/2 with supported browsers. Save the configuration file and exit the text editor. Whenever you make changes to Nginx configuration files, you should check the configuration for syntax errors, like this: $ sudo nginx -t If the syntax is error-free, you will see the following output: nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful Avoid Old Cipher SuitesHTTP/2 has a huge blacklist of old and insecure ciphers, so we must avoid them. Cipher suites are a bunch of cryptographic algorithms, which describe how the transferring data should be encrypted. We will use a really popular cipher set, whose security was approved by Internet giants like CloudFlare. It does not allow the usage of MD5 encryption (which was known as insecure since 1996, but despite this fact, its use is widespread even to this day). Open the following configuration file: $ sudo vim /etc/nginx/nginx.conf Add this line after ssl_prefer_server_ciphers on;: ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; Save the file, and exit the text editor. Once again, check the configuration for syntax errors: $ sudo nginx -t Redirect all HTTP Request to HTTPSSince we are interested in serving the content through HTTPS only, we should tell Nginx what it should do if the server receives an HTTP request. Open the configuration file: $ sudo vim /etc/nginx/sites-available/default At the bottom of our file, we will create a new server block for redirecting all HTTP requests to HTTPS (be sure to replace the server name with your actual domain name): server { listen 80; listen [::]:80; server_name example.com; return 301 https://$server_name$request_uri; } Save the file, and exit the configuration file. Check the configuration for syntax errors: $ sudo nginx -t Reload NginxThat’s it for all the Nginx configuration changes. Since we checked for syntax errors with each change, you should be ready to restart Nginx and test your changes. To summarize, ignoring commented out lines, your configuration file should now look similar to mine: server { listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name pingchuan.ma www.pingchuan.ma; location / { try_files $uri $uri/ =404; } ssl_certificate /etc/letsencrypt/live/pingchuan.ma/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/pingchuan.ma/privkey.pem; include /etc/letsencrypt/options-ssl-nginx.conf; ssl_dhparam /etc/ssl/certs/dhparam.pem; } server { listen 80; listen [::]:80; server_name pingchuan.ma www.pingchuan.ma; return 301 https://$server_name$request_uri; } To apply the changes, restart the Nginx server. $ sudo systemctl restart nginx Verify the ChangesLet’s check that our server is up and running. Open your web browser and navigate to your domain. If everything was configured properly, you should be automatically redirected to HTTPS. Now, let’s check that HTTP/2 is working: open the Chrome Developer Tools (View -&gt; Developer -&gt; Developer Tools) and reload the page (View -&gt; Reload This Page). Then navigate to the Network tab, click on table header row that starts with Name, right-click on it, and select the Protocol option. Now you should see h2 (which stands for HTTP/2) in a new column for your website serving HTTP/2 content. At this point, our server is ready to serve content through HTTP/2 protocol, but there are still some things we should do to prepare the server to be used in production. Optimize Nginx for Best PerformanceIn this step we will tune the main Nginx configuration file for best performance and security. First of all, let’s open nginx.conf by typing the following in the console: $ sudo vim /etc/nginx/nginx.conf Enable Connection Credentials CachingCompared to HTTP, HTTPS takes a relatively longer time to establish initial connection between server and user. To minimize this difference in page load speed, we will enable caching of the connection credentials. That means instead of creating a new session on every page requested, the server will use a cached version of the credentials instead. To enable session caching, add these lines at the end of http block of your nginx.conf file: ssl_session_cache shared:SSL:5m; ssl_session_timeout 1h; ssl_session_cache specifies the size of cache that will contain session information. 1 MB of it can store information for about 4000 sessions. The default value of 5 MB will be more than enough for most users, but if you expect really heavy traffic, you can increase this value accordingly. ssl_session_timeout limits the time particular sessions are stored in the cache. This value shouldn’t be too big (more than an hour), but setting the value too low is pointless as well. Enable HTTP Strict Transport Security (HSTS)Even though we have already made all regular HTTP requests redirect to HTTPS in our Nginx configuration file, we also should enable HTTP Strict Transport Security to avoid having to do those redirects in the first place. If the browser finds an HSTS header, it will not try to connect to the server via regular HTTP again for the given time period. No matter what, it will exchange data using only encrypted HTTPS connection. This header should also protect us from protocol downgrade attacks. Add this line in nginx.conf: add_header Strict-Transport-Security &quot;max-age=15768000&quot; always; The max-age is set in seconds. 15768000 seconds is equivalent to 6 months. By default, this header is not added to subdomain requests. If you have subdomains and want HSTS to apply to all of them, you should add the includeSubDomains variable at the end of the line, like this: add_header Strict-Transport-Security &quot;max-age=15768000; includeSubDomains&quot; always; Save the file, and exit the text editor. Once again, check the configuration for syntax errors: $ sudo nginx -t Finally, restart the Nginx server to apply the changes. $ sudo systemctl restart nginx References How To Set Up Nginx with HTTP/2 Support on Ubuntu 16.04 HTTP/2 - Wikipedia HTTP/2 – A Real-World Performance Test and Analysis]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Equip Nginx Server with HTTPS]]></title>
    <url>%2Fequip-nginx-server-with-https%2F</url>
    <content type="text"><![CDATA[HTTP is the foundation of data communication for the World Wide Web. However, the connection is not so secure as we thought. To keep our information safe and sound, HTTPS was introduced. Next let’s see how to enable HTTPS on website based on Nginx of Ubuntu with the help of Let’s Encrypt. What Is Let’s Encrypt?To enable HTTPS on your website, you need to get a certificate (a type of file) from a Certificate Authority (CA). Let’s Encrypt is a CA. In order to get a certificate for your website’s domain from Let’s Encrypt, you have to demonstrate control over the domain. With Let’s Encrypt, you do this using software that uses the ACME protocol, which typically runs on your web host. How Does HTTPS Work?HTTPS pages typically use one of two secure protocols to encrypt communications - SSL (Secure Sockets Layer) or TLS (Transport Layer Security). Both the TLS and SSL protocols use what is known as an ‘asymmetric’ Public Key Infrastructure (PKI) system. An asymmetric system uses two ‘keys’ to encrypt communications, a ‘public’ key and a ‘private’ key. Anything encrypted with the public key can only be decrypted by the private key and vice versa. As the names suggest, the ‘private’ key should be kept strictly protected and should only be accessible the owner of the private key. In the case of a website, the private key remains securely ensconced on the web server. Conversely, the public key is intended to be distributed to anybody and everybody that needs to be able to decrypt information that was encrypted with the private key. Why Let’s Encrypt?Actually, there are hundreds of CA who can provide certificates. However, it is not always free. Let’s Encrypt is free and open project which is capable for providing creditable certificates. It is supported by plentiful large enterprises. So now let’s move on and try it. How to Make It?Prerequisites An Nginx-installed Ubuntu OS. A non-root user with the right to sudo. You should have the control right of a domain name and associate it with your Nginx-running server. It is recommend that resolve both example.com and www.example.com to your server. E.g. I used CNAME service to redirect www.pingchuan.ma to pingchuan.ma. My DigitalOcean VPS is installed with Ubuntu 16.04 LTS x64. This post will also be based on it. Install CertbotLet’s Encrypt used certbot to deploy SSL certificate automatically for your server. It is not included in Ubuntu’s default repositories so we add it now: $ sudo add-apt-repository ppa:certbot/certbot We should press ENTER to validate your command. Then, we will obtain new package information from the repositories: $ sudo apt-get update After the loading and updating process, we can now install certbot: $ sudo apt-get install python-certbot-nginx Configure Nginxcertbot can automatically configure SSL for Nginx, but it needs to be able to find the correct server block in your configuration file. It does this by looking for a server_name directive that matches the domain we are requesting a certificate for. We can now update the default configuration file: $ sudo vim /etc/nginx/sites-available/default Find the existing server_name line: server_name _; Replace the _ underscore with your domain name: server_name example.com www.example.com; For example, to me, I fill the file with: server_name pingchuan.ma www.pingchuan.ma; If you did not have your www.example.com resolved or it was prepared for other uses, then delete www.example.com from the default configuration file: server_name pingchuan.ma; Save the file and quit vim. Verify the syntax of our configuration edits with: $ sudo nginx -t If that runs with no errors, reload Nginx to load the new configuration: $ sudo systemctl reload nginx Update the FirewallIf you have the ufw enabled, you will need to adjust the settings to allow for HTTPS traffic. If you followed my previous tutorial about building Nginx on Ubuntu, you should have done with it, so skip this part and go to next step. We can see the current setting by typing: $ sudo ufw status It will probably look like this: Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere Nginx HTTP ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) Nginx HTTP (v6) ALLOW Anywhere (v6) . . . To additionally let in HTTPS traffic, we can allow the “Nginx Full” profile and then delete the redundant “Nginx HTTP” profile allowance: $ sudo ufw allow &#39;Nginx Full&#39; $ sudo ufw delete allow &#39;Nginx HTTP&#39; Then you can verify it by typing: $ sudo ufw status Then the status of ufw shows up: Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere Nginx Full ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) Nginx Full (v6) ALLOW Anywhere (v6) . . . Obtain an SSL Certificatecertbot provides a variety of ways to obtain SSL certificates, through various plugins. The Nginx plugin will take care of reconfiguring Nginx and reloading the configuration file whenever necessary: $ sudo certbot --nginx -d example.com -d www.example.com For me, it is: $ sudo certbot --nginx -d pingchuan.ma -d www.pingchuan.ma This runs certbot with the --nginx plugin, using -d to specify the names we’d like the certificate to be valid for. If this is your first time running certbot, you will be prompted to enter an email address and agree to the terms of service. After doing so, certbot will communicate with the Let’s Encrypt server, then run a challenge to verify that you control the domain you’re requesting a certificate for. If that’s successful, certbot will ask how you’d like to configure your HTTPS settings: Please choose whether HTTPS access is required or optional. ------------------------------------------------------------------------------- 1: Easy - Allow both HTTP and HTTPS access to these sites 2: Secure - Make all requests redirect to secure HTTPS access ------------------------------------------------------------------------------- Select the appropriate number [1-2] then [enter] (press &#39;c&#39; to cancel): Select your choice then hit ENTER. The configuration will be updated, and Nginx will reload to pick up the new settings. certbot will wrap up with a message telling us the process was successful and where your certificates are stored: IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at /etc/letsencrypt/live/pingchuan.ma/fullchain.pem. Your cert will expire on 2017-10-29. To obtain a new or tweaked version of this certificate in the future, simply run certbot again with the &quot;certonly&quot; option. To non-interactively renew *all* of your certificates, run &quot;certbot renew&quot; - Your account credentials have been saved in your Certbot configuration directory at /etc/letsencrypt. You should make a secure backup of this folder now. This configuration directory will also contain certificates and private keys obtained by Certbot so making regular backups of this folder is ideal. - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let&#39;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le Our certificates are downloaded, installed, and loaded. Try reloading our website using https:// and notice our browser’s security indicator. It should represent that the site is properly secured, usually with a green lock icon. Update Diffie-Hellman ParametersIf you test your server using the SSL Labs Server Test now, it will only get a B grade due to weak Diffie-Hellman parameters. This effects the security of the initial key exchange between our server and its users. We can fix this by creating a new dhparam.pem file and adding it to our server block. Create the file using openssl: $ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048 This will take quite a while, up to a few minutes. When it’s done, open up the Nginx configuration file that contains our server block: $ sudo vim /etc/nginx/sites-available/default Paste the following line anywhere you like within the server block: ssl_dhparam /etc/ssl/certs/dhparam.pem; Save the file and quit vim, then verify the configuration: $ sudo nginx -t Reload Nginx if there is no errors,: $ sudo systemctl reload nginx Your site is now more secure, and should receive an A rating. Set up Auto RenewalCertificates from Let’s Encrypt certificates are only valid for ninety days. This is to encourage users to automate their certificate renewal process. We will need to set up a regularly run command to check for expiring certificates and renew them automatically. To run the renewal check daily, we will use cron, a standard system service for running periodic jobs. We tell cron what to do by opening and editing a file called a crontab. $ sudo crontab -e Your text editor will open the default crontab which is a text file with some help text in it. Paste in the following line at the end of the file, then save and close it: 15 3 * * * /usr/bin/certbot renew --quiet The 15 3 * * * part of this line means “run the following command at 3:15 am, every day”. You may choose any time. The renew command for certbot will check all certificates installed on the system and update any that are set to expire in less than thirty days. --quiet tells certbot not to output information or wait for user input. cron will now run this command daily. All installed certificates will be automatically renewed and reloaded when they have thirty days or less before they expire. References HTTP to HTTPS | What is a HTTPS Certificate How To Secure Nginx with Let’s Encrypt on Ubuntu 16.04 Getting Started - Let’s Encrypt - Free SSL/TLS Certificates]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install Nginx on Ubuntu]]></title>
    <url>%2Finstall-nginx-on-ubuntu%2F</url>
    <content type="text"><![CDATA[To set up a website based on my VPS, it is necessary to choose a web server which is capable for holding my traffic. When I was a high school boy, I tried to build my personal website on WordPress based on Apache, but I found they are both too extravagant for me. This time, I chose Nginx to hold my website. What Is Nginx?Nginx is one of the most popular web servers in the world and is responsible for hosting some of the largest and highest-traffic sites on the Internet. It is more resource-friendly than Apache in most cases and can be used as a web server or a reverse proxy. Why Nginx?In fact, I have tens of millions of choices, for example, Nginx, Apache, lighttpd, etc. But in my opinion, Nginx is a light-weighted web server which perfectly fits personal users like me. Actually, last semester I enrolled in a JAVA Programming Language course, and I suffered a lot from Apache there. So, this time I tried Nginx out and surprised by its usability. How to Make It?Prerequisites An Internet hosting, such as VPS or cloud hosting. And, it should be running Ubuntu. A non-root user with the right to sudo. My DigitalOcean VPS is installed with Ubuntu 16.04 LTS x64. This post will also be based on it. Install NginxNginx is so popular that Ubuntu’s default repositories included it: $ sudo apt-get update $ sudo apt-get install nginx Configure the Firewall (optional)To secure our server, I highly recommend that set a firewall, such as Uncomplicated Firewall (ufw) to protect it. I will not include the initialization of ufw here. Let’s check the applications list inside ufw: $ sudo ufw app list Then there should be something showed up like: Available applications: Nginx Full Nginx HTTP Nginx HTTPS OpenSSH . . . There are three profiles registered in Nginx: Nginx Full: This profile opens both port 80 (normal, unencrypted web traffic) and port 443 (TLS/SSL encrypted traffic) Nginx HTTP: This profile opens only port 80 (normal, unencrypted web traffic) Nginx HTTPS: This profile opens only port 443 (TLS/SSL encrypted traffic) For example, to allow HTTP traffic and to prepare for enabling HTTPS, I will type this: $ sudo ufw allow &#39;Nginx Full&#39; Then we can verify it by typing: $ sudo ufw status Then the status of ufw shows up: Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere Nginx Full ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) Nginx Full (v6) ALLOW Anywhere (v6) . . . Is It working?To check if Nginx is running, we should type: $ systemctl status nginx If it IS running, the output should be something like: ● nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2017-08-06 16:22:46 HKT; 1h 3min ago Process: 1611 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS) Process: 1498 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0 Main PID: 1615 (nginx) Tasks: 2 Memory: 11.7M CPU: 121ms CGroup: /system.slice/nginx.service ├─1615 nginx: master process /usr/sbin/nginx -g daemon on; master_process on └─1616 nginx: worker process This is mine, and since it is not identical for everyone, yours should differ from my version. However, if you see running on the screen, you made it. If you have got your IP address or have assigned your domain name to your IP address with DNS’s help, go and have a look at it through browser. http://server_domain_or_IP Then here is the default welcome page of Nginx: Basic CommandsNow that you have your web server up and running, we can go over some basic management commands. To stop your web server, you can type: $ sudo systemctl stop nginx To start the web server when it is stopped, type: $ sudo systemctl start nginx To stop and then start the service again, type: $ sudo systemctl restart nginx If you are simply making configuration changes, Nginx can often reload without dropping connections. To do this, this command can be used: $ sudo systemctl reload nginx By default, Nginx is configured to start automatically when the server boots. If this is not what you want, you can disable this behavior by typing: $ sudo systemctl disable nginx To re-enable the service to start up at boot, you can type: $ sudo systemctl enable nginx References How To Install Nginx on Ubuntu 16.04 Install | NGINX]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install Node.js on Ubuntu Using NVM]]></title>
    <url>%2Finstall-node-js-on-ubuntu-using-nvm%2F</url>
    <content type="text"><![CDATA[Node.js is a Javascript platform for server-side programming that allows users to build network applications quickly. By leveraging Javascript on both the front-end and the back-end, development can be more consistent and be designed within the same system. IntroductionA popular approach to installing Node.js through apt is to use a specially designed tool called nvm, which stands for “Node.js version manager”. Using nvm, you can install multiple, self-contained versions of Node.js which will allow you to control your environment easier. It will give you on-demand access to the newest versions of Node.js, but will also allow you to target previous releases that your app may depend on. Get Necessary PackagesTo start off, we’ll need to get the software packages from our Ubuntu repositories that will allow us to build source packages. The nvm script will leverage these tools to build the necessary components: $ sudo apt-get update $ sudo apt-get install build-essential libssl-dev Download NVMOnce the prerequisite packages are installed, you can pull down the nvm installation script from the project’s GitHub page. The version number may be different, but in general, you can download and install it with the following syntax: $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.4/install.sh | bash This will download the script and run it. It will install the software into a subdirectory of your home directory at ~/.nvm. It will also add the necessary lines to your ~/.profile file to use the file. To gain access to the nvm functionality, you’ll need to log out and log back in again, or you can source the ~/.profile file so that your current session knows about the changes: $ source ~/.profile Now that you have nvm installed, you can install isolated Node.js versions. Install Node.jsTo install the latest stable version of Node.js, all you should do is type: $ nvm install node Advanced OperationsTo find out the versions of Node.js that are available for installation, you can type: $ nvm ls-remote . . . v8.0.0 v8.1.0 v8.1.1 v8.1.2 v8.1.3 v8.1.4 v8.2.0 v8.2.1 v8.3.0 v8.4.0 As you can see, the newest version at the time of this writing is v8.4.0. You can install that by typing: $ nvm install 8.4.0 Usually, nvm will switch to use the most recently installed version. You can explicitly tell nvm to use the version we just downloaded by typing: $ nvm use 8.4.0 When you install Node.js using nvm, the executable is called node. You can see the version currently being used by the shell by typing: $ node -v v8.4.0 If you have multiple Node.js versions, you can see what is installed by typing: $ nvm ls If you wish to default one of the versions, you can type: $ nvm alias default 8.4.0 This version will be automatically selected when a new session spawns. You can also reference it by the alias like this: $ nvm use default Each version of Node.js will keep track of its own packages and has npm available to manage these. You can have npm install packages to the Node.js project’s ./node_modules directory by using the normal format: $ npm install express If you’d like to install it globally (available to the other projects using the same Node.js version), you can add the -g flag: $ npm install -g express This will install the package in: $ ~/.nvm/node_version/lib/node_modules/package_name Installing globally will let you run the commands from the command line, but you’ll have to use link the package into your local sphere to require it from within a program: $ npm link express You can learn more about the options available to you with nvm by typing: $ nvm help References How To Install Node.js on an Ubuntu 14.04 server Node Version Manager - Simple bash script to manage multiple active node.js versions]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Free Free Internet]]></title>
    <url>%2Ffree-free-internet%2F</url>
    <content type="text"><![CDATA[As a Chinese university student, it is especially difficult for me to accomplish my research with Google or Wikipedia. Additionally, my university is using a tolling network, whose Internet fee is about $0.3/GB. It is not a big deal but it bothered me anyway. Despite the inconvenience discussed above, it is totally free to get online through IPv6. Apparently, if I convert my IPv4 network traffic into IPv6 one and introduce an unblocked hosting server to agent it, all problem will be settled. In a nutshell, I am going to: get online free (free of charge) through IPv6; reach out for free (unrestricted) Internet; What Is Shadowsocks?According to its GitHub description, shadowsocks works as a fast tunnel proxy with several friendly features: TCP &amp; UDP support User management API TCP Fast Open Workers and graceful restart Destination IP blacklist As for many people, this multi-featured tool plays an indispensable role in research and study. In particular, it serves me well in network testing and website boosting. Why Shadowsocks?Technically speaking, I did not really figure out how it works. However, to my experience, shadowsocks can maximum my network securely. Moreover, I find it friendly and easy to build for a Linux newbie like me. As a result, I chose shadowsocks. Rumor has it that the censorship is fighting against shadowsocks, but I believe that technology and science commit no crime. I am not good at memorization, so I recorded my building steps for further reference. How to Make It?Prerequisites An Internet hosting, such as VPS or cloud hosting. DigitalOcean’s VPS service is good enough for me. I would not like to discuss the choosing of hosting service here. My DigitalOcean VPS is installed with Ubuntu 16.04 LTS x64. This post will also be based on it. Install PipI am building with python3, so I need pip for python3. Omit it if you have installed it. $ sudo apt-get update $ sudo apt-get install python3-pip Install ShadowsocksThe author of shadowsocks stopped the maintenance in official pip, so we get the latest version via git. $ sudo pip3 install git+https://github.com/shadowsocks/shadowsocks.git@master To look up the version of shadowsocks, we should use this command: $ sudo ssserver --version If shadowsocks has been installed successfully, it should show this: Shadowsocks 3.0.0 Implement Safer Encryption Methods (optional)According to the introduction of encryption: rc4-md5 is a safe, fast encryption that use different key per connection. It is recommended for OpenWRT routers. salsa20 and chacha20 are fast stream ciphers. Optimized salsa20 implementation on x86_64 is even 2x faster than rc4 (but slightly slower on ARM). For me, I chose chacha20 as my encryption method. Let’s install the requirements: $ sudo apt-get install python-m2crypto $ sudo apt-get install build-essential $ wget https://github.com/jedisct1/libsodium/releases/download/1.0.13/libsodium-1.0.13.tar.gz $ sudo tar xf libsodium-1.0.13.tar.gz &amp;&amp; cd libsodium-1.0.13 $ sudo ./configure &amp;&amp; sudo make -j2 $ sudo make install $ sudo ldconfig Work with Configuration FileTo configure the shadowsocks, we create a configuration file: $ sudo vim /etc/shadowsocks.json Then we fill our configuration file with details: (do not forget to change the ports and passwords) { &quot;server&quot;: &quot;::&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;: 1080, &quot;port_password&quot;: { &quot;10001&quot;: &quot;password1&quot;, &quot;10002&quot;: &quot;password2&quot; }, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;chacha20&quot;, &quot;fast_open&quot;: false } We set the value of server to :: in order to ask shadowsocks to receive the traffic from both IPv4 and IPv6. method means the encryption method you want shadowsocks to arm with. And fast_open field will be discuss later in the optimization. UsageTo run shadowsocks in the background: $ sudo ssserver -c /etc/shadowsocks.json -d start To stop it: $ sudo ssserver -d stop Run with StartupUbuntu 16.04 introduced a new module named Systemd to manage system and service. We are using the fresh features here. Create the management file of shadowsocks: $ sudo vim /etc/systemd/system/shadowsocks-server.service Then paste the configuration content: [Unit] Description = Shadowsocks Server After = network.target [Service] ExecStart = /usr/local/bin/ssserver -c /etc/shadowsocks.json Restart = on-abort [Install] WantedBy = multi-user.target So now we get a new approach to run shadowsocks: $ sudo systemctl start shadowsocks-server Make shadowsocks run with startup in case of accidentally crash and reboot: $ sudo systemctl enable shadowsocks-server OptimizationsHere are some trick to optimize the performance of shadowsocks. Enable BBRBBR stands for a brand new congestion control algorithm developed by Google. It can boost our server to a large extent. Update Linux KernelBBR is impossible to enable as long as Linux kernel version is lower than 4.9.0. So firstly let’s check the version of kernel: $ uname -r If it shows a version compatible with BBR, please skip to “Edit Configuration File”. Go to a temporary download folder with command cd to prepare for kernel. Then download the latest stable kernel from kernel PPA webpage. For example, I chose v4.12.4 mainline build for amd64 succeeded: $ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-headers-4.12.4-041204_4.12.4-041204.201707271932_all.deb $ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-headers-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb $ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-image-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb Then we install the kernels we downloaded: $ sudo dpkg -i *.deb Then we should reboot and delete the old kernels: $ sudo purge-old-kernels Edit Configuration FileLet’s check if we have already switched BBR on: $ sudo lsmod | grep bbr If there is not tcp_bbr in the results, we follow this to enable it: $ sudo echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf $ sudo echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf Then we save the configuration file and make it go into effort: $ sudo sysctl -p Validate$ sysctl net.ipv4.tcp_available_congestion_control $ sysctl net.ipv4.tcp_congestion_control If the results both contain bbr, we are sure that BBR has been enabled. Optimize I/OTo make it, we create a configuration file: $ sudo vim /etc/sysctl.d/local.conf Then we fill it with some settings: # max open files fs.file-max = 51200 # max read buffer net.core.rmem_max = 67108864 # max write buffer net.core.wmem_max = 67108864 # default read buffer net.core.rmem_default = 65536 # default write buffer net.core.wmem_default = 65536 # max processor input queue net.core.netdev_max_backlog = 4096 # max backlog net.core.somaxconn = 4096 # resist SYN flood attacks net.ipv4.tcp_syncookies = 1 # reuse timewait sockets when safe net.ipv4.tcp_tw_reuse = 1 # turn off fast timewait sockets recycling net.ipv4.tcp_tw_recycle = 0 # short FIN timeout net.ipv4.tcp_fin_timeout = 30 # short keepalive time net.ipv4.tcp_keepalive_time = 1200 # outbound port range net.ipv4.ip_local_port_range = 10000 65000 # max SYN backlog net.ipv4.tcp_max_syn_backlog = 4096 # max timewait sockets held by system simultaneously net.ipv4.tcp_max_tw_buckets = 5000 # turn on TCP Fast Open on both client and server side net.ipv4.tcp_fastopen = 3 # TCP receive buffer net.ipv4.tcp_rmem = 4096 87380 67108864 # TCP write buffer net.ipv4.tcp_wmem = 4096 65536 67108864 # turn on path MTU discovery net.ipv4.tcp_mtu_probing = 1 # for low-latency network, use cubic instead # net.ipv4.tcp_congestion_control = cubic Then we make it come into effort: $ sudo sysctl --system Then edit the shadowsocks-server.service file above: $ sudo vim /etc/systemd/system/shadowsocks-server.service Insert a line before ExecStart: ExecStartPre = /bin/sh -c &#39;ulimit -n 51200&#39; Overall shadowsocks-server.service: [Unit] Description = Shadowsocks Server After = network.target [Service] ExecStartPre = /bin/sh -c &#39;ulimit -n 51200&#39; ExecStart = /usr/local/bin/ssserver -c /etc/shadowsocks.json Restart = on-abort [Install] WantedBy = multi-user.target Make them come into effort: $ sudo systemctl daemon-reload $ sudo systemctl restart shadowsocks-server Enable TCP Fast OpenTCP Fast Open is designed to reduce delay between server and clients. Now it is the time to enable it. Edit our shadowsocks configuration file: $ sudo vim /etc/shadowsocks.json Then we set the value of fast_open to true. Restart shadowsocks to validate your changes. $ sudo systemctl restart shadowsocks-server References Ubuntu 16.04 下 Shadowsocks 伺服器端安装及優化 (The installation and optimization of Shadowsocks server in Ubuntu 16.04) 我是如何在天津大学上網的 (How do I get online in Tianjin University)]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Network</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[This is my first post!]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
  </entry>
</search>
