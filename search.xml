<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Install Nginx on Ubuntu]]></title>
    <url>%2Finstall-nginx-on-ubuntu%2F</url>
    <content type="text"><![CDATA[To set up a website based on my VPS, it is necessary to choose a web server which is capable for holding my traffic. When I am a high school boy, I tried to build my personal website on WordPress based on Apache, but I found they are both too extravagant for me. This time, I chose Nginx to hold my website. What is Nginx?Nginx is one of the most popular web servers in the world and is responsible for hosting some of the largest and highest-traffic sites on the Internet. It is more resource-friendly than Apache in most cases and can be used as a web server or a reverse proxy. Why Nginx?In fact, I have tens of millions of choices, for example, Nginx, Apache, lighttpd, etc. But in my opinion, Nginx is a light-weighted web server which perfectly fits personal users like me. Actually, last semester I enrolled in a JAVA Programming Language course, and I suffered a lot from Apache there. So, this time I tried Nginx out and surprised by its usability. How to make it?Prerequisites An Internet hosting, such as VPS or cloud hosting. And, it should be running Ubuntu. A non-root user with the right to sudo. My DigitalOcean VPS is installed with Ubuntu 16.04 LTS x64. The post will also be based on it. Install NginxNginx is so popular that Ubuntu’s default repositories included it: $ sudo apt-get update $ sudo apt-get install nginx Configure the Firewall (optional)To secure our server, I highly recommend that set a firewall, such as Uncomplicated Firewall (ufw) to protect it. I will not include the initialization of ufw here. Let’s check the applications list inside ufw: $ sudo ufw app list Then there should be something showed up like: Available applications: Nginx Full Nginx HTTP Nginx HTTPS OpenSSH ... There are three profiles registered in Nginx: Nginx Full: This profile opens both port 80 (normal, unencrypted web traffic) and port 443 (TLS/SSL encrypted traffic) Nginx HTTP: This profile opens only port 80 (normal, unencrypted web traffic) Nginx HTTPS: This profile opens only port 443 (TLS/SSL encrypted traffic) For example, I am using both HTTP and HTTPS now so I will type: $ sudo ufw allow &#39;Nginx Full&#39; Then you can verify it by typing: $ sudo ufw status Then the status of ufw shows up: Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere Nginx Full ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) Nginx Full (v6) ALLOW Anywhere (v6) Is it working?To check if Nginx is running, we should type: $ systemctl status nginx If it IS running, the output should be something like: ● nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2017-08-06 16:22:46 HKT; 1h 3min ago Process: 1611 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS) Process: 1498 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0 Main PID: 1615 (nginx) Tasks: 2 Memory: 11.7M CPU: 121ms CGroup: /system.slice/nginx.service ├─1615 nginx: master process /usr/sbin/nginx -g daemon on; master_process on └─1616 nginx: worker process This is mine, and since it is not identical for everyone, yours should differ from my version. However, if you see running on the screen, you made it. If you have got your IP address or have assigned your domain name to your IP address with DNS’s help, go and have a look at it through browser. http://server_domain_or_IP Then here is the default welcome page of Nginx: Basic CommandsNow that you have your web server up and running, we can go over some basic management commands. To stop your web server, you can type: $ sudo systemctl stop nginx To start the web server when it is stopped, type: $ sudo systemctl start nginx To stop and then start the service again, type: $ sudo systemctl restart nginx If you are simply making configuration changes, Nginx can often reload without dropping connections. To do this, this command can be used: $ sudo systemctl reload nginx By default, Nginx is configured to start automatically when the server boots. If this is not what you want, you can disable this behavior by typing: $ sudo systemctl disable nginx To re-enable the service to start up at boot, you can type: $ sudo systemctl enable nginx]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Network</tag>
        <tag>Ubuntu</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Free Free Internet]]></title>
    <url>%2Ffree-free-internet%2F</url>
    <content type="text"><![CDATA[IntroductionAs a Chinese university student, I am enjoying a special-designed Internet as we all know. Needless to say that it is especially difficult for me to accomplish my research with Google or Wikipedia. Additionally, my university is using a tolling network, whose Internet fee is about $0.3/GB. It is not a big deal but it bothered me anyway. Despite the inconvenience discussed above, it is totally free to get online through IPv6. Apparently, if I convert my IPv4 network traffic into IPv6 one and introduce a hosting server to agent it, all problem will be settled. In a nutshell, I am going to: get online free (free of charge) through IPv6; reach out for free (unrestricted) Internet; What is Shadowsocks?According to its GitHub description, shadowsocks works as a fast tunnel proxy with several friendly features: TCP &amp; UDP support User management API TCP Fast Open Workers and graceful restart Destination IP blacklist As for many people, this multi-featured tool plays an indispensable role in research and study. In particular, it serves me well in network testing and website boosting. Why Shadowsocks?Technically speaking, I did not really figure out how it works. However, to my experience, shadowsocks can maximum my network securely. Moreover, I find it friendly and easy to build for a Linux newbie like me. As a result, I chose shadowsocks. Rumor has it that the censorship is fighting against shadowsocks, but I believe that technology and science commit no crime. I am not good at memorization, so I recorded my building steps for further reference. How to Make it?Prerequisites An Internet hosting, such as VPS or cloud hosting. DigitalOcean’s VPS service is good enough for me. I would not like to discuss the choosing of hosting service here. My DigitalOcean VPS is installed with Ubuntu 16.04 LTS x64. The post will also be based on it. Install pipI am building with python3, so I need pip for python3. Omit it if you have installed it. $ sudo apt-get update $ sudo apt-get install python3-pip Install shadowsocksThe author of shadowsocks stopped the maintenance in official pip, so we get the latest version via git. $ sudo pip3 install git+https://github.com/shadowsocks/shadowsocks.git@master To look up the version of shadowsocks, we should use this command: $ sudo ssserver --version If shadowsocks has been installed successfully, it should show this: Shadowsocks 3.0.0 Implement Safer Encryption Method (optional)According to the introduction of encryption: rc4-md5 is a safe, fast encryption that use different key per connection. It is recommended for OpenWRT routers. salsa20 and chacha20 are fast stream ciphers. Optimized salsa20 implementation on x86_64 is even 2x faster than rc4 (but slightly slower on ARM). For me, I chose chacha20 as my encryption method. Let’s install the requirements: $ sudo apt-get install python-m2crypto $ sudo apt-get install build-essential $ wget https://github.com/jedisct1/libsodium/releases/download/1.0.13/libsodium-1.0.13.tar.gz $ sudo tar xf libsodium-1.0.13.tar.gz &amp;&amp; cd libsodium-1.0.13 $ sudo ./configure &amp;&amp; sudo make -j2 $ sudo make install $ sudo ldconfig Work with Configuration FileTo configure the shadowsocks, we create a configuration file: $ sudo vim /etc/shadowsocks.json Then we fill our configuration file with details: (do not forget to change the ports and passwords) { &quot;server&quot;: &quot;::&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;: 1080, &quot;port_password&quot;: { &quot;10001&quot;: &quot;password1&quot;, &quot;10002&quot;: &quot;password2&quot; }, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;chacha20&quot;, &quot;fast_open&quot;: false } We set the value of server to :: in order to ask shadowsocks to receive the traffic from both IPv4 and IPv6. method means the encryption method you want shadowsocks to arm with. And fast_open field will be discuss later in the optimization. UsageTo run shadowsocks in the background: $ sudo ssserver -c /etc/shadowsocks.json -d start To stop it: $ sudo ssserver -d stop Run with StartupUbuntu 16.04 introduced a new module named Systemd to manage system and service. We are using the fresh features here. Create the management file of shadowsocks: $ sudo vim /etc/systemd/system/shadowsocks-server.service Then paste the configuration content: [Unit] Description = Shadowsocks Server After = network.target [Service] ExecStart = /usr/local/bin/ssserver -c /etc/shadowsocks.json Restart = on-abort [Install] WantedBy = multi-user.target So now we get a new approach to run shadowsocks: $ sudo systemctl start shadowsocks-server Make shadowsocks run with startup in case of accidentally crash and reboot: $ sudo systemctl enable shadowsocks-server OptimizationsHere are some trick to optimize the performance of shadowsocks. Enable BBRBBR stands for a brand new congestion control algorithm developed by Google. It can boost our server to a large extent. Update Linux KernelBBR is impossible to enable as long as Linux kernel version is lower than 4.9.0. So firstly let’s check the version of kernel: $ uname -r If it shows a version compatible with BBR, please skip to “Edit Configuration File”. Go to a temporary download folder with command cd to prepare for kernel. Then download the latest stable kernel from kernel PPA webpage. For example, I chose v4.12.4 mainline build for amd64 succeeded: $ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-headers-4.12.4-041204_4.12.4-041204.201707271932_all.deb $ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-headers-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb $ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-image-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb Then we install the kernels we downloaded: $ sudo dpkg -i *.deb Then we should reboot and delete the old kernels: $ sudo purge-old-kernels Edit Configuration FileLet’s check if we have already switched BBR on: $ sudo lsmod | grep bbr If there is not tcp_bbr in the results, we follow this to enable it: $ sudo echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf $ sudo echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf Then we save the configuration file and make it go into effort: $ sudo sysctl -p Validate$ sysctl net.ipv4.tcp_available_congestion_control $ sysctl net.ipv4.tcp_congestion_control If the results both contain bbr, we are sure that BBR has been enabled. Optimize I/OTo make it, we create a configuration file: $ sudo vim /etc/sysctl.d/local.conf Then we fill it with some settings: # max open files fs.file-max = 51200 # max read buffer net.core.rmem_max = 67108864 # max write buffer net.core.wmem_max = 67108864 # default read buffer net.core.rmem_default = 65536 # default write buffer net.core.wmem_default = 65536 # max processor input queue net.core.netdev_max_backlog = 4096 # max backlog net.core.somaxconn = 4096 # resist SYN flood attacks net.ipv4.tcp_syncookies = 1 # reuse timewait sockets when safe net.ipv4.tcp_tw_reuse = 1 # turn off fast timewait sockets recycling net.ipv4.tcp_tw_recycle = 0 # short FIN timeout net.ipv4.tcp_fin_timeout = 30 # short keepalive time net.ipv4.tcp_keepalive_time = 1200 # outbound port range net.ipv4.ip_local_port_range = 10000 65000 # max SYN backlog net.ipv4.tcp_max_syn_backlog = 4096 # max timewait sockets held by system simultaneously net.ipv4.tcp_max_tw_buckets = 5000 # turn on TCP Fast Open on both client and server side net.ipv4.tcp_fastopen = 3 # TCP receive buffer net.ipv4.tcp_rmem = 4096 87380 67108864 # TCP write buffer net.ipv4.tcp_wmem = 4096 65536 67108864 # turn on path MTU discovery net.ipv4.tcp_mtu_probing = 1 # for low-latency network, use cubic instead # net.ipv4.tcp_congestion_control = cubic Then we make it come into effort: $ sudo sysctl --system Then edit the shadowsocks-server.service file above: $ sudo vim /etc/systemd/system/shadowsocks-server.service Insert a line before ExecStart: ExecStartPre = /bin/sh -c &#39;ulimit -n 51200&#39; Overall shadowsocks-server.service: [Unit] Description = Shadowsocks Server After = network.target [Service] ExecStartPre = /bin/sh -c &#39;ulimit -n 51200&#39; ExecStart = /usr/local/bin/ssserver -c /etc/shadowsocks.json Restart = on-abort [Install] WantedBy = multi-user.target Make them come into effort: $ sudo systemctl daemon-reload $ sudo systemctl restart shadowsocks-server Enable TCP Fast OpenTCP Fast Open is designed to reduce delay between server and clients. Now it is the time to enable it. Edit our shadowsocks configuration file: $ sudo vim /etc/shadowsocks.json Then we set the value of fast_open to true. Restart shadowsocks to validate your changes. $ sudo systemctl restart shadowsocks-server]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Network</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[This is my first post!]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
  </entry>
</search>
