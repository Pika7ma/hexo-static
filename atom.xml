<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OpenPIKA</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pingchuan.ma/"/>
  <updated>2017-08-07T07:36:43.000Z</updated>
  <id>https://pingchuan.ma/</id>
  
  <author>
    <name>Pingchuan Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Equip Nginx Server With HTTPS</title>
    <link href="https://pingchuan.ma/equip-nginx-server-with-https/"/>
    <id>https://pingchuan.ma/equip-nginx-server-with-https/</id>
    <published>2017-08-07T05:57:47.000Z</published>
    <updated>2017-08-07T07:36:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HTTP</strong> is the foundation of data communication for the World Wide Web. However, the connection is not so secure as we thought. To keep our information safe and sound, <strong>HTTPS</strong> was introduced. Next let’s see how to enable HTTPS on website based on Nginx of Ubuntu with the help of <strong>Let’s Encrypt</strong>.</p>
<a id="more"></a>
<h2 id="What-is-Let’s-Encrypt"><a href="#What-is-Let’s-Encrypt" class="headerlink" title="What is Let’s Encrypt?"></a>What is Let’s Encrypt?</h2><p>To enable HTTPS on your website, you need to get a certificate (a type of file) from a <strong>Certificate Authority</strong> (<strong>CA</strong>). <a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a> is a CA. In order to get a certificate for your website’s domain from Let’s Encrypt, you have to demonstrate control over the domain. With Let’s Encrypt, you do this using software that uses the ACME protocol, which typically runs on your web host.</p>
<h2 id="How-does-HTTPS-work"><a href="#How-does-HTTPS-work" class="headerlink" title="How does HTTPS work?"></a>How does HTTPS work?</h2><p>HTTPS pages typically use one of two secure protocols to encrypt communications - <strong>SSL</strong> (<strong>Secure Sockets Layer</strong>) or <strong>TLS</strong> (<strong>Transport Layer Security</strong>). Both the TLS and SSL protocols use what is known as an ‘asymmetric’ <strong>Public Key Infrastructure</strong> (<strong>PKI</strong>) system. An asymmetric system uses two ‘keys’ to encrypt communications, a ‘public’ key and a ‘private’ key. Anything encrypted with the public key can only be decrypted by the private key and vice versa.</p>
<p>As the names suggest, the ‘private’ key should be kept strictly protected and should only be accessible the owner of the private key. In the case of a website, the private key remains securely ensconced on the web server. Conversely, the public key is intended to be distributed to anybody and everybody that needs to be able to decrypt information that was encrypted with the private key.</p>
<div align="center"><br><img src="/equip-nginx-server-with-https/http-vs-https.png" alt="HTTP v.s. HTTPS" title="HTTP v.s. HTTPS"><br></div>

<h2 id="Why-Let’s-Encrypt"><a href="#Why-Let’s-Encrypt" class="headerlink" title="Why Let’s Encrypt?"></a>Why Let’s Encrypt?</h2><p>Actually, there are hundreds of CA who can provide certificates. However, it is not always free. Let’s Encrypt is free and open project which is capable for providing creditable certificates. It is supported by plentiful large enterprises. So now let’s move on and try it.</p>
<h2 id="How-to-make-it"><a href="#How-to-make-it" class="headerlink" title="How to make it?"></a>How to make it?</h2><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><ul>
<li>A Nginx-installed Ubuntu OS.</li>
<li>A non-root user with the right to <code>sudo</code>.</li>
<li>You should have the control right of a domain name and associate it with your Nginx-running server. It is recommend that resolve both <code>example.com</code> and <code>www.example.com</code> to your server. E.g. I used CNAME service to redirect <code>www.pingchuan.ma</code> to <code>pingchuan.ma</code>.</li>
</ul>
<p>My <a href="https://m.do.co/c/c037166332e8" title="Click here to get $10 in credit." target="_blank" rel="external">DigitalOcean</a> VPS is installed with Ubuntu 16.04 LTS x64. This post will also be based on it.</p>
<h3 id="Install-Certbot"><a href="#Install-Certbot" class="headerlink" title="Install Certbot"></a>Install Certbot</h3><p>Let’s Encrypt used <code>certbot</code> to deploy SSL certificate automatically for your server. It is not included in Ubuntu’s default repositories so we add it now:</p>
<pre><code class="bash">$ sudo add-apt-repository ppa:certbot/certbot
</code></pre>
<p>We should press <code>ENTER</code> to validate your command. Then, we will obtain new package information from the repositories:</p>
<pre><code class="bash">$ sudo apt-get update
</code></pre>
<p>After the loading and updating process, we can now install <code>certbot</code>:</p>
<pre><code class="bash">$ sudo apt-get install python-certbot-nginx
</code></pre>
<h3 id="Configure-Nginx"><a href="#Configure-Nginx" class="headerlink" title="Configure Nginx"></a>Configure Nginx</h3><p><code>certbot</code> can automatically configure SSL for Nginx, but it needs to be able to find the correct <code>server</code> block in your configuration file. It does this by looking for a <code>server_name</code> directive that matches the domain we are requesting a certificate for. We can now update the default configuration file:</p>
<pre><code class="bash">$ sudo vim /etc/nginx/sites-available/default
</code></pre>
<p>Find the existing <code>server_name</code> line:</p>
<pre><code>server_name _;
</code></pre><p>Replace the <code>_</code> underscore with your domain name:</p>
<pre><code>server_name example.com www.example.com;
</code></pre><p>For example, to me, I fill the file with:</p>
<pre><code>server_name pingchuan.ma www.pingchuan.ma;
</code></pre><p>If you did not have your <code>www.example.com</code> resolved or it was prepared for other uses, then delete <code>www.example.com</code> from the default configuration file:</p>
<pre><code>server_name pingchuan.ma;
</code></pre><p>Save the file and quit <code>vim</code>. Verify the syntax of our configuration edits with:</p>
<pre><code class="bash">$ sudo nginx -t
</code></pre>
<p>If that runs with no errors, reload Nginx to load the new configuration:</p>
<pre><code>$ sudo systemctl reload nginx
</code></pre><h3 id="Update-the-Firewall"><a href="#Update-the-Firewall" class="headerlink" title="Update the Firewall"></a>Update the Firewall</h3><p>If you have the <code>ufw</code> enabled, you will need to adjust the settings to allow for HTTPS traffic. If you followed my <a href="https://pingchuan.ma/install-nginx-on-ubuntu/">last tutorial</a> about building Nginx on Ubuntu, you should have done with it, so skip this part and go to next step.</p>
<p>We can see the current setting by typing:</p>
<pre><code class="bash">$ sudo ufw status
</code></pre>
<p>It will probably look like this:</p>
<pre><code class="bash">Status: active

To                  Action      From
--                  ------      ----
OpenSSH             ALLOW       Anywhere                  
Nginx HTTP          ALLOW       Anywhere                  
OpenSSH (v6)        ALLOW       Anywhere (v6)             
Nginx HTTP (v6)     ALLOW       Anywhere (v6)
</code></pre>
<p>To additionally let in HTTPS traffic, we can allow the “Nginx Full” profile and then delete the redundant “Nginx HTTP” profile allowance:</p>
<pre><code class="bash">$ sudo ufw allow &#39;Nginx Full&#39;
$ sudo ufw delete allow &#39;Nginx HTTP&#39;
</code></pre>
<p>Then you can verify it by typing:</p>
<pre><code class="bash">$ sudo ufw status
</code></pre>
<p>Then the status of <code>ufw</code> shows up:</p>
<pre><code class="bash">Status: active

To                  Action      From
--                  ------      ----
OpenSSH             ALLOW       Anywhere                  
Nginx Full          ALLOW       Anywhere                  
OpenSSH (v6)        ALLOW       Anywhere (v6)             
Nginx Full (v6)     ALLOW       Anywhere (v6)
</code></pre>
<h3 id="Obtain-an-SSL-Certificate"><a href="#Obtain-an-SSL-Certificate" class="headerlink" title="Obtain an SSL Certificate"></a>Obtain an SSL Certificate</h3><p><code>certbot</code> provides a variety of ways to obtain SSL certificates, through various plugins. The Nginx plugin will take care of reconfiguring Nginx and reloading the configuration file whenever necessary:</p>
<pre><code class="bash">$ sudo certbot --nginx -d example.com -d www.example.com
</code></pre>
<p>For me, it is:</p>
<pre><code class="bash">$ sudo certbot --nginx -d pingchuan.ma -d www.pingchuan.ma
</code></pre>
<p>This runs <code>certbot</code> with the <code>--nginx</code> plugin, using <code>-d</code> to specify the names we’d like the certificate to be valid for.</p>
<p>If this is your first time running <code>certbot</code>, you will be prompted to enter an email address and agree to the terms of service. After doing so, <code>certbot</code> will communicate with the Let’s Encrypt server, then run a challenge to verify that you control the domain you’re requesting a certificate for.</p>
<p>If that’s successful, <code>certbot</code> will ask how you’d like to configure your HTTPS settings:</p>
<pre><code class="bash">Please choose whether HTTPS access is required or optional.
-------------------------------------------------------------------------------
1: Easy - Allow both HTTP and HTTPS access to these sites
2: Secure - Make all requests redirect to secure HTTPS access
-------------------------------------------------------------------------------
Select the appropriate number [1-2] then [enter] (press &#39;c&#39; to cancel):
</code></pre>
<p>Select your choice then hit <code>ENTER</code>. The configuration will be updated, and Nginx will reload to pick up the new settings. <code>certbot</code> will wrap up with a message telling us the process was successful and where your certificates are stored:</p>
<pre><code class="bash">IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at
   /etc/letsencrypt/live/pingchuan.ma/fullchain.pem. Your cert will
   expire on 2017-10-29. To obtain a new or tweaked version of this
   certificate in the future, simply run certbot again with the
   &quot;certonly&quot; option. To non-interactively renew *all* of your
   certificates, run &quot;certbot renew&quot;
 - Your account credentials have been saved in your Certbot
   configuration directory at /etc/letsencrypt. You should make a
   secure backup of this folder now. This configuration directory will
   also contain certificates and private keys obtained by Certbot so
   making regular backups of this folder is ideal.
 - If you like Certbot, please consider supporting our work by:

   Donating to ISRG / Let&#39;s Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le
</code></pre>
<p>Our certificates are downloaded, installed, and loaded. Try reloading our website using <code>https://</code> and notice our browser’s security indicator. It should represent that the site is properly secured, usually with a green lock icon.</p>
<div align="center"><br><img src="/equip-nginx-server-with-https/https-browsers.png" alt="HTTPS browsers" title="HTTPS browsers"><br></div>

<h3 id="Update-Diffie-Hellman-Parameters"><a href="#Update-Diffie-Hellman-Parameters" class="headerlink" title="Update Diffie-Hellman Parameters"></a>Update Diffie-Hellman Parameters</h3><p>If you test your server using the <a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="external">SSL Labs Server Test</a> now, it will only get a <strong>B</strong> grade due to weak Diffie-Hellman parameters. This effects the security of the initial key exchange between our server and its users. We can fix this by creating a new <code>dhparam.pem</code> file and adding it to our <code>server</code> block.</p>
<p>Create the file using <code>openssl</code>:</p>
<pre><code class="bash">$ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048
</code></pre>
<p>This will take quite a while, up to a few minutes. When it’s done, open up the Nginx configuration file that contains our server block:</p>
<pre><code class="bash">$ sudo vim /etc/nginx/sites-available/default
</code></pre>
<p>Paste the following line anywhere you like within the <code>server</code> block:</p>
<pre><code>...
ssl_dhparam /etc/ssl/certs/dhparam.pem;
...
</code></pre><p>Save the file and quit <code>vim</code>, then verify the configuration:</p>
<pre><code class="bash">$ sudo nginx -t
</code></pre>
<p>Reload Nginx if there is no errors,:</p>
<pre><code class="bash">$ sudo systemctl reload nginx
</code></pre>
<p>Your site is now more secure, and should receive an <strong>A</strong> rating.</p>
<h3 id="Set-Up-Auto-Renewal"><a href="#Set-Up-Auto-Renewal" class="headerlink" title="Set Up Auto Renewal"></a>Set Up Auto Renewal</h3><p>Certificates from Let’s Encrypt certificates are only valid for ninety days. This is to encourage users to automate their certificate renewal process. We will need to set up a regularly run command to check for expiring certificates and renew them automatically.</p>
<p>To run the renewal check daily, we will use cron, a standard system service for running periodic jobs. We tell <code>cron</code> what to do by opening and editing a file called a <code>crontab</code>.</p>
<pre><code class="bash">$ sudo crontab -e
</code></pre>
<p>Your text editor will open the default <code>crontab</code> which is a text file with some help text in it. Paste in the following line at the end of the file, then save and close it:</p>
<pre><code>...
15 3 * * * /usr/bin/certbot renew --quiet
...
</code></pre><p>The <code>15 3 * * *</code> part of this line means “run the following command at 3:15 am, every day”. You may choose any time.</p>
<p>The renew command for <code>certbot</code> will check all certificates installed on the system and update any that are set to expire in less than thirty days. <code>--quiet</code> tells <code>certbot</code> not to output information or wait for user input.</p>
<p><code>cron</code> will now run this command daily. All installed certificates will be automatically renewed and reloaded when they have thirty days or less before they expire.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><p><a href="https://www.instantssl.com/ssl-certificate-products/https.html" target="_blank" rel="external">HTTP to HTTPS | What is a HTTPS Certificate</a></p>
</li>
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-16-04" target="_blank" rel="external">How To Secure Nginx with Let’s Encrypt on Ubuntu 16.04</a></p>
</li>
<li><p><a href="https://letsencrypt.org/getting-started/" target="_blank" rel="external">Getting Started - Let’s Encrypt - Free SSL/TLS Certificates</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt; is the foundation of data communication for the World Wide Web. However, the connection is not so secure as we thought. To keep our information safe and sound, &lt;strong&gt;HTTPS&lt;/strong&gt; was introduced. Next let’s see how to enable HTTPS on website based on Nginx of Ubuntu with the help of &lt;strong&gt;Let’s Encrypt&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="https://pingchuan.ma/categories/network/"/>
    
    
      <category term="Nginx" scheme="https://pingchuan.ma/tags/nginx/"/>
    
      <category term="Ubuntu" scheme="https://pingchuan.ma/tags/ubuntu/"/>
    
      <category term="Linux" scheme="https://pingchuan.ma/tags/linux/"/>
    
      <category term="Network" scheme="https://pingchuan.ma/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Install Nginx on Ubuntu</title>
    <link href="https://pingchuan.ma/install-nginx-on-ubuntu/"/>
    <id>https://pingchuan.ma/install-nginx-on-ubuntu/</id>
    <published>2017-08-06T08:22:22.000Z</published>
    <updated>2017-08-07T07:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>To set up a website based on my VPS, it is necessary to choose a web server which is capable for holding my traffic. When I was a high school boy, I tried to build my personal website on <strong>WordPress</strong> based on Apache, but I found they are both too extravagant for me. This time, I chose <strong>Nginx</strong> to hold my website.</p>
<a id="more"></a>
<h2 id="What-is-Nginx"><a href="#What-is-Nginx" class="headerlink" title="What is Nginx?"></a>What is Nginx?</h2><p><a href="https://www.nginx.com/" target="_blank" rel="external">Nginx</a> is one of the most popular web servers in the world and is responsible for hosting some of the largest and highest-traffic sites on the Internet. It is more resource-friendly than Apache in most cases and can be used as a web server or a reverse proxy.</p>
<h2 id="Why-Nginx"><a href="#Why-Nginx" class="headerlink" title="Why Nginx?"></a>Why Nginx?</h2><p>In fact, I have tens of millions of choices, for example, <strong>Nginx</strong>, <strong>Apache</strong>, <strong>lighttpd</strong>, etc. But in my opinion, Nginx is a light-weighted web server which perfectly fits personal users like me. Actually, last semester I enrolled in a <strong>JAVA Programming Language</strong> course, and I suffered a lot from Apache there. So, this time I tried Nginx out and surprised by its usability.</p>
<h2 id="How-to-make-it"><a href="#How-to-make-it" class="headerlink" title="How to make it?"></a>How to make it?</h2><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><ul>
<li>An Internet hosting, such as VPS or cloud hosting. And, it should be running Ubuntu.</li>
<li>A non-root user with the right to <code>sudo</code>.</li>
</ul>
<p>My <a href="https://m.do.co/c/c037166332e8" title="Click here to get $10 in credit." target="_blank" rel="external">DigitalOcean</a> VPS is installed with Ubuntu 16.04 LTS x64. This post will also be based on it.</p>
<h3 id="Install-Nginx"><a href="#Install-Nginx" class="headerlink" title="Install Nginx"></a>Install Nginx</h3><p>Nginx is so popular that Ubuntu’s default repositories included it:</p>
<pre><code class="bash">$ sudo apt-get update
$ sudo apt-get install nginx
</code></pre>
<h3 id="Configure-the-Firewall-optional"><a href="#Configure-the-Firewall-optional" class="headerlink" title="Configure the Firewall (optional)"></a>Configure the Firewall (optional)</h3><p>To secure our server, I highly recommend that set a firewall, such as <a href="https://help.ubuntu.com/community/UFW" target="_blank" rel="external">Uncomplicated Firewall</a> (<code>ufw</code>) to protect it. I will not include the initialization of <code>ufw</code> here.</p>
<p>Let’s check the applications list inside <code>ufw</code>:</p>
<pre><code class="bash">$ sudo ufw app list
</code></pre>
<p>Then there should be something showed up like:</p>
<pre><code class="bash">Available applications:
  Nginx Full
  Nginx HTTP
  Nginx HTTPS
  OpenSSH
  ...
</code></pre>
<p>There are three profiles registered in Nginx:</p>
<ul>
<li><strong>Nginx Full</strong>: This profile opens both port 80 (normal, unencrypted web traffic) and port 443 (TLS/SSL encrypted traffic)</li>
<li><strong>Nginx HTTP</strong>: This profile opens only port 80 (normal, unencrypted web traffic)</li>
<li><strong>Nginx HTTPS</strong>: This profile opens only port 443 (TLS/SSL encrypted traffic)</li>
</ul>
<p>For example, to allow HTTP traffic and to prepare for enabling HTTPS, I will type this:</p>
<pre><code class="bash">$ sudo ufw allow &#39;Nginx Full&#39;
</code></pre>
<p>Then we can verify it by typing:</p>
<pre><code class="bash">$ sudo ufw status
</code></pre>
<p>Then the status of <code>ufw</code> shows up:</p>
<pre><code class="bash">Status: active

To                  Action      From
--                  ------      ----
OpenSSH             ALLOW       Anywhere                  
Nginx Full          ALLOW       Anywhere                  
OpenSSH (v6)        ALLOW       Anywhere (v6)             
Nginx Full (v6)     ALLOW       Anywhere (v6)
</code></pre>
<h3 id="Is-it-working"><a href="#Is-it-working" class="headerlink" title="Is it working?"></a>Is it working?</h3><p>To check if Nginx is running, we should type:</p>
<pre><code class="bash">$ systemctl status nginx
</code></pre>
<p>If it IS running, the output should be something like:</p>
<pre><code class="bash">● nginx.service - A high performance web server and a reverse proxy server
   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)
   Active: active (running) since Sun 2017-08-06 16:22:46 HKT; 1h 3min ago
  Process: 1611 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
  Process: 1498 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0
 Main PID: 1615 (nginx)
    Tasks: 2
   Memory: 11.7M
      CPU: 121ms
   CGroup: /system.slice/nginx.service
           ├─1615 nginx: master process /usr/sbin/nginx -g daemon on; master_process on
           └─1616 nginx: worker process
</code></pre>
<p>This is mine, and since it is not identical for everyone, yours should differ from my version. However, if you see <code>running</code> on the screen, you made it.</p>
<p>If you have got your IP address or have assigned your domain name to your IP address with DNS’s help, go and have a look at it through browser.</p>
<pre><code>http://server_domain_or_IP
</code></pre><p>Then here is the default welcome page of Nginx:</p>
<div align="center"><br><img src="/install-nginx-on-ubuntu/nginx_default_page.png" alt="Nginx Default Page" title="Nginx Default Page"><br></div>

<h2 id="Basic-Commands"><a href="#Basic-Commands" class="headerlink" title="Basic Commands"></a>Basic Commands</h2><p>Now that you have your web server up and running, we can go over some basic management commands.</p>
<p>To stop your web server, you can type:</p>
<pre><code class="bash">$ sudo systemctl stop nginx
</code></pre>
<p>To start the web server when it is stopped, type:</p>
<pre><code class="bash">$ sudo systemctl start nginx
</code></pre>
<p>To stop and then start the service again, type:</p>
<pre><code class="bash">$ sudo systemctl restart nginx
</code></pre>
<p>If you are simply making configuration changes, Nginx can often reload without dropping connections. To do this, this command can be used:</p>
<pre><code class="bash">$ sudo systemctl reload nginx
</code></pre>
<p>By default, Nginx is configured to start automatically when the server boots. If this is not what you want, you can disable this behavior by typing:</p>
<pre><code class="bash">$ sudo systemctl disable nginx
</code></pre>
<p>To re-enable the service to start up at boot, you can type:</p>
<pre><code class="bash">$ sudo systemctl enable nginx
</code></pre>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-16-04" target="_blank" rel="external">How To Install Nginx on Ubuntu 16.04</a></li>
<li><a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/" target="_blank" rel="external">Install | NGINX</a></li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;To set up a website based on my VPS, it is necessary to choose a web server which is capable for holding my traffic. When I was a high school boy, I tried to build my personal website on &lt;strong&gt;WordPress&lt;/strong&gt; based on Apache, but I found they are both too extravagant for me. This time, I chose &lt;strong&gt;Nginx&lt;/strong&gt; to hold my website.&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="https://pingchuan.ma/categories/network/"/>
    
    
      <category term="Nginx" scheme="https://pingchuan.ma/tags/nginx/"/>
    
      <category term="Ubuntu" scheme="https://pingchuan.ma/tags/ubuntu/"/>
    
      <category term="Linux" scheme="https://pingchuan.ma/tags/linux/"/>
    
      <category term="Network" scheme="https://pingchuan.ma/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Free Free Internet</title>
    <link href="https://pingchuan.ma/free-free-internet/"/>
    <id>https://pingchuan.ma/free-free-internet/</id>
    <published>2017-08-03T03:46:22.000Z</published>
    <updated>2017-08-07T07:45:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>As a Chinese university student, I am enjoying a special-designed Internet as we all know. Needless to say that it is especially difficult for me to accomplish my research with Google or Wikipedia.</p>
<p>Additionally, my university is using a tolling network, whose Internet fee is about $0.3/GB. It is not a big deal but it bothered me anyway. </p>
<p>Despite the inconvenience discussed above, it is totally free to get online through <strong>IPv6</strong>. Apparently, if I convert my IPv4 network traffic into IPv6 one and introduce a hosting server to agent it, all problem will be settled.</p>
<p>In a nutshell, I am going to:</p>
<ol>
<li>get online <strong>free</strong> (free of charge) through IPv6;</li>
<li>reach out for <strong>free</strong> (unrestricted) Internet;</li>
</ol>
<a id="more"></a>
<h2 id="What-is-Shadowsocks"><a href="#What-is-Shadowsocks" class="headerlink" title="What is Shadowsocks?"></a>What is Shadowsocks?</h2><p>According to its <a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="external">GitHub</a> description, <strong>shadowsocks</strong> works as a fast tunnel proxy with several friendly features:</p>
<ul>
<li>TCP &amp; UDP support</li>
<li>User management API</li>
<li>TCP Fast Open</li>
<li>Workers and graceful restart</li>
<li>Destination IP blacklist</li>
</ul>
<p>As for many people, this multi-featured tool plays an indispensable role in research and study. In particular, it serves me well in network testing and website boosting.</p>
<h2 id="Why-Shadowsocks"><a href="#Why-Shadowsocks" class="headerlink" title="Why Shadowsocks?"></a>Why Shadowsocks?</h2><p>Technically speaking, I did not really figure out how it works. However, to my experience, shadowsocks can maximum my network <strong>securely</strong>. Moreover, I find it friendly and easy to build for a Linux newbie like me. As a result, I chose shadowsocks.</p>
<p>Rumor has it that the censorship is fighting against shadowsocks, but I believe that <strong>technology and science commit no crime</strong>. I am not good at memorization, so I recorded my building steps for further reference.</p>
<h2 id="How-to-Make-it"><a href="#How-to-Make-it" class="headerlink" title="How to Make it?"></a>How to Make it?</h2><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><ul>
<li>An Internet hosting, such as VPS or cloud hosting. <em>DigitalOcean’s VPS service is good enough for me. I would not like to discuss the choosing of hosting service here.</em></li>
</ul>
<p>My <a href="https://m.do.co/c/c037166332e8" title="Click here to get $10 in credit." target="_blank" rel="external">DigitalOcean</a> VPS is installed with Ubuntu 16.04 LTS x64. This post will also be based on it.</p>
<h3 id="Install-pip"><a href="#Install-pip" class="headerlink" title="Install pip"></a>Install pip</h3><p>I am building with python3, so I need pip for python3. Omit it if you have installed it.</p>
<pre><code class="bash">$ sudo apt-get update
$ sudo apt-get install python3-pip
</code></pre>
<h3 id="Install-shadowsocks"><a href="#Install-shadowsocks" class="headerlink" title="Install shadowsocks"></a>Install shadowsocks</h3><p>The author of shadowsocks stopped the maintenance in official pip, so we get the latest version via git.</p>
<pre><code class="bash">$ sudo pip3 install git+https://github.com/shadowsocks/shadowsocks.git@master
</code></pre>
<p>To look up the version of shadowsocks, we should use this command:</p>
<pre><code class="bash">$ sudo ssserver --version
</code></pre>
<p>If shadowsocks has been installed successfully, it should show this:</p>
<pre><code class="bash">Shadowsocks 3.0.0
</code></pre>
<h3 id="Implement-Safer-Encryption-Methods-optional"><a href="#Implement-Safer-Encryption-Methods-optional" class="headerlink" title="Implement Safer Encryption Methods (optional)"></a>Implement Safer Encryption Methods (optional)</h3><p>According to the <a href="https://github.com/shadowsocks/shadowsocks/wiki/Encryption" target="_blank" rel="external">introduction</a> of encryption:</p>
<blockquote>
<p><code>rc4-md5</code> is a safe, fast encryption that use different key per connection. It is recommended for OpenWRT routers.</p>
<p><code>salsa20</code> and <code>chacha20</code> are fast stream ciphers. Optimized <code>salsa20</code> implementation on x86_64 is even 2x faster than <code>rc4</code> (but slightly slower on ARM).</p>
</blockquote>
<p>For me, I chose chacha20 as my encryption method. Let’s install the requirements:</p>
<pre><code class="bash">$ sudo apt-get install python-m2crypto
$ sudo apt-get install build-essential
$ wget https://github.com/jedisct1/libsodium/releases/download/1.0.13/libsodium-1.0.13.tar.gz
$ sudo tar xf libsodium-1.0.13.tar.gz &amp;&amp; cd libsodium-1.0.13
$ sudo ./configure &amp;&amp; sudo make -j2
$ sudo make install
$ sudo ldconfig
</code></pre>
<h3 id="Work-with-Configuration-File"><a href="#Work-with-Configuration-File" class="headerlink" title="Work with Configuration File"></a>Work with Configuration File</h3><p>To configure the shadowsocks, we create a configuration file:</p>
<pre><code class="bash">$ sudo vim /etc/shadowsocks.json
</code></pre>
<p>Then we fill our configuration file with details: (do not forget to change the ports and passwords)</p>
<pre><code class="json">{
    &quot;server&quot;: &quot;::&quot;,
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,
    &quot;local_port&quot;: 1080,
    &quot;port_password&quot;: {
         &quot;10001&quot;: &quot;password1&quot;,
         &quot;10002&quot;: &quot;password2&quot; 
    },
    &quot;timeout&quot;: 300,
    &quot;method&quot;: &quot;chacha20&quot;,
    &quot;fast_open&quot;: false
}
</code></pre>
<p>We set the value of <code>server</code> to <code>::</code> in order to ask shadowsocks to receive the traffic from both IPv4 and <strong>IPv6</strong>. <code>method</code> means the encryption method you want shadowsocks to arm with. And <code>fast_open</code> field will be discuss later in the optimization.</p>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>To run shadowsocks in the background:</p>
<pre><code class="bash">$ sudo ssserver -c /etc/shadowsocks.json -d start
</code></pre>
<p>To stop it:</p>
<pre><code class="bash">$ sudo ssserver -d stop
</code></pre>
<h3 id="Run-with-Startup"><a href="#Run-with-Startup" class="headerlink" title="Run with Startup"></a>Run with Startup</h3><p>Ubuntu 16.04 introduced a new module named Systemd to manage system and service. We are using the fresh features here.</p>
<p>Create the management file of shadowsocks:</p>
<pre><code class="bash">$ sudo vim /etc/systemd/system/shadowsocks-server.service
</code></pre>
<p>Then paste the configuration content:</p>
<pre><code>[Unit]
Description = Shadowsocks Server
After = network.target

[Service]
ExecStart = /usr/local/bin/ssserver -c /etc/shadowsocks.json
Restart = on-abort

[Install]
WantedBy = multi-user.target
</code></pre><p>So now we get a new approach to run shadowsocks:</p>
<pre><code class="bash">$ sudo systemctl start shadowsocks-server
</code></pre>
<p>Make shadowsocks run with startup in case of accidentally crash and reboot:</p>
<pre><code class="bash">$ sudo systemctl enable shadowsocks-server
</code></pre>
<h2 id="Optimizations"><a href="#Optimizations" class="headerlink" title="Optimizations"></a>Optimizations</h2><p>Here are some trick to optimize the performance of shadowsocks.</p>
<h3 id="Enable-BBR"><a href="#Enable-BBR" class="headerlink" title="Enable BBR"></a>Enable BBR</h3><p>BBR stands for a brand new congestion control algorithm developed by Google. It can boost our server to a large extent.</p>
<h4 id="Update-Linux-Kernel"><a href="#Update-Linux-Kernel" class="headerlink" title="Update Linux Kernel"></a>Update Linux Kernel</h4><p>BBR is impossible to enable as long as Linux kernel version is lower than 4.9.0. So firstly let’s check the version of kernel:</p>
<pre><code class="bash">$ uname -r
</code></pre>
<p>If it shows a version compatible with BBR, please skip to “Edit Configuration File”.</p>
<p>Go to a temporary download folder with command <code>cd</code> to prepare for kernel. Then download the latest stable kernel from <a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank" rel="external">kernel PPA webpage</a>. For example, I chose v4.12.4 mainline build for amd64 succeeded:</p>
<pre><code class="bash">$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-headers-4.12.4-041204_4.12.4-041204.201707271932_all.deb
$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-headers-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb
$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.12.4/linux-image-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb
</code></pre>
<p>Then we install the kernels we downloaded:</p>
<pre><code class="bash">$ sudo dpkg -i *.deb
</code></pre>
<p>Then we should <code>reboot</code> and delete the old kernels:</p>
<pre><code class="bash">$ sudo purge-old-kernels
</code></pre>
<h4 id="Edit-Configuration-File"><a href="#Edit-Configuration-File" class="headerlink" title="Edit Configuration File"></a>Edit Configuration File</h4><p>Let’s check if we have already switched BBR on:</p>
<pre><code class="bash">$ sudo lsmod | grep bbr
</code></pre>
<p>If there is not <code>tcp_bbr</code> in the results, we follow this to enable it:</p>
<pre><code class="bash">$ sudo echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf
$ sudo echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf
</code></pre>
<p>Then we save the configuration file and make it go into effort:</p>
<pre><code class="bash">$ sudo sysctl -p
</code></pre>
<h4 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h4><pre><code class="bash">$ sysctl net.ipv4.tcp_available_congestion_control
$ sysctl net.ipv4.tcp_congestion_control
</code></pre>
<p>If the results both contain <code>bbr</code>, we are sure that BBR has been enabled.</p>
<h3 id="Optimize-I-O"><a href="#Optimize-I-O" class="headerlink" title="Optimize I/O"></a>Optimize I/O</h3><p>To make it, we create a configuration file:</p>
<pre><code class="bash">$ sudo vim /etc/sysctl.d/local.conf
</code></pre>
<p>Then we fill it with some settings:</p>
<pre><code># max open files
fs.file-max = 51200
# max read buffer
net.core.rmem_max = 67108864
# max write buffer
net.core.wmem_max = 67108864
# default read buffer
net.core.rmem_default = 65536
# default write buffer
net.core.wmem_default = 65536
# max processor input queue
net.core.netdev_max_backlog = 4096
# max backlog
net.core.somaxconn = 4096

# resist SYN flood attacks
net.ipv4.tcp_syncookies = 1
# reuse timewait sockets when safe
net.ipv4.tcp_tw_reuse = 1
# turn off fast timewait sockets recycling
net.ipv4.tcp_tw_recycle = 0
# short FIN timeout
net.ipv4.tcp_fin_timeout = 30
# short keepalive time
net.ipv4.tcp_keepalive_time = 1200
# outbound port range
net.ipv4.ip_local_port_range = 10000 65000
# max SYN backlog
net.ipv4.tcp_max_syn_backlog = 4096
# max timewait sockets held by system simultaneously
net.ipv4.tcp_max_tw_buckets = 5000
# turn on TCP Fast Open on both client and server side
net.ipv4.tcp_fastopen = 3
# TCP receive buffer
net.ipv4.tcp_rmem = 4096 87380 67108864
# TCP write buffer
net.ipv4.tcp_wmem = 4096 65536 67108864
# turn on path MTU discovery
net.ipv4.tcp_mtu_probing = 1

# for low-latency network, use cubic instead
# net.ipv4.tcp_congestion_control = cubic
</code></pre><p>Then we make it come into effort:</p>
<pre><code class="bash">$ sudo sysctl --system
</code></pre>
<p>Then edit the <code>shadowsocks-server.service</code> file above:</p>
<pre><code class="bash">$ sudo vim /etc/systemd/system/shadowsocks-server.service
</code></pre>
<p>Insert a line before <code>ExecStart</code>:</p>
<pre><code>ExecStartPre = /bin/sh -c &#39;ulimit -n 51200&#39;
</code></pre><p>Overall <code>shadowsocks-server.service</code>:</p>
<pre><code>[Unit]
Description = Shadowsocks Server
After = network.target

[Service]
ExecStartPre = /bin/sh -c &#39;ulimit -n 51200&#39;
ExecStart = /usr/local/bin/ssserver -c /etc/shadowsocks.json
Restart = on-abort

[Install]
WantedBy = multi-user.target
</code></pre><p>Make them come into effort:</p>
<pre><code class="bash">$ sudo systemctl daemon-reload
$ sudo systemctl restart shadowsocks-server
</code></pre>
<h3 id="Enable-TCP-Fast-Open"><a href="#Enable-TCP-Fast-Open" class="headerlink" title="Enable TCP Fast Open"></a>Enable TCP Fast Open</h3><p>TCP Fast Open is designed to reduce delay between server and clients. Now it is the time to enable it.</p>
<p>Edit our shadowsocks configuration file:</p>
<pre><code class="bash">$ sudo vim /etc/shadowsocks.json
</code></pre>
<p>Then we set the value of <code>fast_open</code> to <code>true</code>. Restart shadowsocks to validate your changes.</p>
<pre><code class="bash">$ sudo systemctl restart shadowsocks-server
</code></pre>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://www.polarxiong.com/archives/Ubuntu-16-04%E4%B8%8BShadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BC%98%E5%8C%96.html" target="_blank" rel="external">Ubuntu 16.04 下 Shadowsocks 伺服器端安装及優化 (The installation and optimization of Shadowsocks server in Ubuntu 16.04)</a></li>
<li><a href="http://b.mindy.tk/tjunet" target="_blank" rel="external">我是如何在天津大学上網的 (How do I get online in Tianjin University)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;As a Chinese university student, I am enjoying a special-designed Internet as we all know. Needless to say that it is especially difficult for me to accomplish my research with Google or Wikipedia.&lt;/p&gt;
&lt;p&gt;Additionally, my university is using a tolling network, whose Internet fee is about $0.3/GB. It is not a big deal but it bothered me anyway. &lt;/p&gt;
&lt;p&gt;Despite the inconvenience discussed above, it is totally free to get online through &lt;strong&gt;IPv6&lt;/strong&gt;. Apparently, if I convert my IPv4 network traffic into IPv6 one and introduce a hosting server to agent it, all problem will be settled.&lt;/p&gt;
&lt;p&gt;In a nutshell, I am going to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;get online &lt;strong&gt;free&lt;/strong&gt; (free of charge) through IPv6;&lt;/li&gt;
&lt;li&gt;reach out for &lt;strong&gt;free&lt;/strong&gt; (unrestricted) Internet;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Network" scheme="https://pingchuan.ma/categories/network/"/>
    
    
      <category term="Ubuntu" scheme="https://pingchuan.ma/tags/ubuntu/"/>
    
      <category term="Linux" scheme="https://pingchuan.ma/tags/linux/"/>
    
      <category term="Network" scheme="https://pingchuan.ma/tags/network/"/>
    
      <category term="Python" scheme="https://pingchuan.ma/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://pingchuan.ma/hello-world/"/>
    <id>https://pingchuan.ma/hello-world/</id>
    <published>2017-08-02T15:04:10.000Z</published>
    <updated>2017-08-06T08:38:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is my first post!</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;This is my first post!&lt;/em&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="Uncategorized" scheme="https://pingchuan.ma/categories/uncategorized/"/>
    
    
  </entry>
  
</feed>
